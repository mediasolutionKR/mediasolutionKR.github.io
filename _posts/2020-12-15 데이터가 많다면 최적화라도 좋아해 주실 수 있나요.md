---
title: "데이터가 많다면 최적화라도 좋아해 주실 수 있나요?"
date: 2020-12-15 13:34:00
categories: Optimization
---

# 여러개의 기기들 상태 데이터를 빠르게 보여주고 싶어요!

![스크린샷 2020-12-15 오후 3 13 48](https://user-images.githubusercontent.com/16532326/102178128-39eb7880-3ee8-11eb-80d1-8507e2c4eba1.png)

위의 사진은 관리자 페이지에서 건물 내 설치된 키오스크들의 현재 화면 상태를 모니터링 하는 화면입니다. 매 10초 마다 각각의 기기들로 부터 상태 데이터를 받아 들이며, 관리자 페이지에서는 매 10초 마다 API 서버에 요청을 걸어 기기들의 최신 상태를 받아 옵니다.

![스크린샷 2020-12-15 오후 3 29 13](https://user-images.githubusercontent.com/16532326/102179338-4d97de80-3eea-11eb-8676-0d56f903e8a2.png)

위와 같이 플로우가 진행되어지는데 문제가 되어지는 부분은 각 기기들의 수 만큼 이미지를 로드 하는 부분에서 발생합니다.

![asdfasdf](https://user-images.githubusercontent.com/16532326/102179867-3f968d80-3eeb-11eb-85d9-99a461296f57.jpg)

저거 가지고 왜? 어떤 문제가 발생되는데? 

> 1. 너무 큰 사이즈의 이미지를 다운로드 함으로 인해 발생되는 트래픽 처리량 증가
>
> 2. HTTP 1.1 사용으로 인한 같은 도메인 내 동시 다운로드 제한
>
> 3. 이미 DB에 등록된 상태 값 데이터가 많아짐으로 인해 발생되는 쿼리 성능 저하

에이 저 문제들 가지고 많이 나빠 지겠어?

![debc3651bde675ea908bffbf7017801d-simpsons-meme-simpsons-quotes-700x](https://user-images.githubusercontent.com/16532326/102180188-cba8b500-3eeb-11eb-82ee-7ea188082e08.jpg)

라고 생각했었지만 실제로 처리를 해보니 현재 기기 상태를 가져오는데만 약 5초가 소요되었고 웹 서비스 특성상 1초를 기다리지 못 하는 클라이언트에겐 좋지 못한 성능을 보여주고 있었습니다.

3가지 문제들을 해결해 내간 과정에 대한 내용을 하단에 기술해볼까 합니다.

## 1. 너무 큰 사이즈의 이미지를 다운로드 함으로 인해 발생되는 트래픽 처리량 증가

각 기기들의 해상도는 FHD 세로형 입니다. 즉, 매 10초 마다 FHD 해상도의 스크린 샷을 찍은 후 서버에 전송을 하게 됩니다. 

![스크린샷 2020-12-15 오후 3 42 19](https://user-images.githubusercontent.com/16532326/102180401-26421100-3eec-11eb-963d-9c5d9a759a82.png)

하지만, 아까 보았던 것과 같이 각 기기별 화면 상태를 보여주는 영역의 크기를 살펴보면 약 126 X 153 의 크기로 사진을 출력하고 있습니다.

FHD 급 해상도의 이미지가 필요 없으며, 위의 경우 16대의 화면을 렌더링 하고 있으니 FHD X 16 사진을 한 화면에서 렌더링 할 필요가 없습니다.

그리하여 서버사이드 이미지 압축 방식을 구현해야 했습니다.

```
return sharp(fileSavedPath)
        .png({compressionLevel: 9, adaptiveFiltering: true, force: true})
        .resize(270, 480)
        .toFile(destPath);
}
```

[sharp](https://www.npmjs.com/package/sharp) 을 이용해 최대한 압축을 하며 해상도를 270 X 480 형태로 줄임으로서 50KB 대의 이미지를 생성하며, 다운로드 할 수 있게끔 구현을 하였습니다.

하지만 이로인해 생기는 문제가 있었는데 동시에 매 10초 마다 16대의 기기들이 사진을 보낼때마다 압축이 되어지는 바람에 CPU 사용률이 높아지게 되었습니다.

다행이 이 부분은 쉽게 해결되었는데 바로 각 기기들에서 보내기 전에 기기 단에서 압축을 한 이미지를 업로드 하게끔 클라이언트 개발자와 협의를 하였습니다. 각 기기들은 CPU 자원 사용률이 평균 50%도 안되는 여유로운 상태였기 때문에 서버에 할 일을 몰아주지 않고, 분산시켜서 작업이 되어지게끔 변경을 하였고 덕분에 서버의 자원 사용량은 적어지면서 이미지 전송 트래픽은 줄일 수 있었습니다.

![다운로드](https://user-images.githubusercontent.com/16532326/102181486-03186100-3eee-11eb-9d24-2692ccd95c2e.png)

물론 제가 관리할 코드가 적어 졌다는게 제일 기분이 좋았지만 말이죠

## 2. HTTP 1.1 사용으로 인한 같은 도메인 내 동시 다운로드 제한

안타깝게도 저희 서비스는 내부적으로 사용되어지는 관리자 페이지이므로 도메인과 HTTPS 가 사용되어지지 않았습니다. 그렇다면 HTTP1.1 을 사용해야 한다는 이야기가 되는데 여기서 문제가 생깁니다.

![다운로드 (1)](https://user-images.githubusercontent.com/16532326/102181733-7de17c00-3eee-11eb-8601-ff73b88aaa45.png)

HTTP 1.1 의 가장 큰 특징은 HTTP 1.0 당시 매 요청이 끝나면 새로운 요청을 체결하였고 한 요청이 끝날 때 까지 기다렸기 때문에 지속적 연결과 pipeline 으로 여러개의 요청을 보낼 수 있게끔 변경되었습니다.

하지만 이 부분도 문제점이 브라우저 별로 HTTP1.1 기준 보낼 수 있는 요청의 수 가 제한되어 있다는 점입니다.

![스크린샷 2020-12-15 오후 4 01 38](https://user-images.githubusercontent.com/16532326/102181980-d9136e80-3eee-11eb-9bf7-b7c871dc0243.png)

대략 이런 식이죠. 그럼 위에 보았던 기기별 상태 화면에선 16대의 기기를 보아야 하지만 경우에 따라선 동시에 화면 이미지가 다운로드 되어지지 않고, 6 개 씩 나누어서 갱신되어지게 됩니다.
물론 HTTP2.0 의 경우엔 한 도메인에 여러개 요청이 제한되어 있지는 않아 바로 해결될 수 있는 문제이죠.

![hqdefault](https://user-images.githubusercontent.com/16532326/102182312-648cff80-3eef-11eb-8781-e9f3676dfc81.jpg)

[stack ref](https://stackoverflow.com/a/36847527/7270469) 하지만 경우에 따라선 제한이 있을 순 있다는 것 같지만

내부망이었기 때문에 도메인 사기엔 좀 그랬기에 이미지를 비동기로 다운받아온 다음 한번에 갱신하는 로직을 구현하게 됩니다. 한땀 한땀

```
  getMonitScreens(monitoringList: MonitoringModel[]) {
    const prom: any[] = [];
    monitoringList.forEach(monit => {
      if (monit.deviceStatusJson && monit.deviceStatusJson.length > 0 && monit.deviceStatusJson[0].rfid) {
        const latestMonit = monit.deviceStatusJson[0];
        prom.push(this.downMonitScreen(
          monit.kid,
          `<API_IMAGE_DOWNLOAD_URL>`,
          latestMonit.contentType
        ));
      } else {
        monit.blobUrl = '<DEFAULT_IMG_URL>';
      }
    });
    return this.allSettled(prom);
  }
```

각 기기들 상태를 배열로 받아 들이고 현재 상태 정보가 담긴 json object 에서 이미지 정보를 참조하여 `Promise` 로 이미지 다운 로직을 호출 하였고 각 `Promise` 객체는 

```
prom.push(this.downMonitScreen(
          monit.kid,
          `<API_IMAGE_DOWNLOAD_URL>`,
          latestMonit.contentType
        ));
```

`prom`으로 선언하였던 배열에 `push` 하였습니다.

이후 모든 `Promise` 객체가 완료되었을 시 콜백을 반환 받기 위해 allSettled 로 호출한 결과를 반환하도록 하였습니다.

이렇게 되어지면 모든 이미지가 비동기로 다운이 받아지게 되며 모든 이미지가 다 다운 된 다음 작업을 진행 할 수 있기 때문에 웹 페이지 화면에도 기기 화면들을 한번에 갱신 할 수 있게 되었습니다.

